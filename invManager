local manager = peripheral.find("inventoryManager")
local owner = manager.getOwner()
local chatBox = peripheral.find("chatBox")
local chatBoxName = "Inventory Manager"
local storeName = "minecraft:chest_1"
local storePeripheral = peripheral.wrap(storeName)
local storeChest = "right"
local takeName = "minecraft:chest_0"
local takePeripheral = peripheral.wrap(takeName)
local takeChest = "up"

chatFunctions = {

	privateMessage = function(text, player)
		local chatMessage = {
			{text = "(Private) ", color = "gray", italic = true},
		}
		chatMessage[2] = text
		chatMessage = textutils.serializeJSON(chatMessage)
		chatBox.sendFormattedMessageToPlayer(chatMessage, player, chatBoxName)
	end

}

functions = {

	take = function(commands)
		local desiredItem = string.lower(commands[1])
		local desiredQuantity = tonumber(commands[2])
		
		if desiredQuantity == nil or desiredQuantity < 1 then 
			desiredQuantity = 1 
		end
		
		if manager.getFreeSlot() ~= -1 then
		
			local value, value2 = manager.addItemToPlayer(takeChest, {name=desiredItem, count = desiredQuantity})
			--Successful
			if value > 0 and value2 == nil then
				chatFunctions.privateMessage({text = "Took "..value.." "..desiredItem..".", color = "green", bold = true}, owner)
			--Incorrect Command
			elseif value2 == "ITEM_NOT_FOUND" then
				chatFunctions.privateMessage({text = "Improper item name (mod:item_name)", color = "red", bold = true}, owner)
			--Chest does not have item
			elseif value2 == nil then
				chatFunctions.privateMessage({text = "Chest does not contain item.", color = "red", bold = true}, owner)
			--Other error
			else
				chatFunctions.privateMessage({text = "Error (Show Gamer):".. value2, color = "red", bold = true}, owner)
			end
		--No space in inventory
		else
			chatFunctions.privateMessage({text = "No empty space in inventory.", color = "red", bold = true}, owner)
		end
	end,
	
	store = function(commands)
	
		local desiredItem = manager.getItemInHand()
		local desiredQuantity = tonumber(commands[1])
		
		if desiredQuantity == nil or desiredQuantity < 1 then 
			desiredQuantity = desiredItem.count
		end
		
		if desiredItem.name ~= nil then
			local value, value2 = manager.removeItemFromPlayer(storeChest, {name=desiredItem.name, count=desiredQuantity})
			storePeripheral.pushItems(takeName, 1)
			--Successful
			if value > 0 and value2 == nil then
				chatFunctions.privateMessage({text = "Stored "..value.." "..desiredItem.name..".", color = "green", bold = true}, owner)
			--No Chest
			elseif value2 == "INVENTORY_TO_INVALID" then
				chatFunctions.privateMessage({text = "No chest to store items.", color = "red", bold = true}, owner)
			--Chest has no storage
			elseif value == 0 then
				chatFunctions.privateMessage({text = "Chest is full.", color = "red", bold = true}, owner)
			--Other Error
			else
				chatFunctions.privateMessage({text = "Error (Show Gamer):".. value2, color = "red", bold = true}, owner)
			end
		--No item in hand
		else
			local chatMessage = {
				{text = "(Private) ", color = "gray", italic = true},
				{text = "No item in hand.", color = "red", bold = true}
			}
			chatMessage = textutils.serializeJSON(chatMessage)
			
			chatBox.sendFormattedMessageToPlayer(chatMessage, owner, chatBoxName)	
		end
		
	end,

	list = function(commands)
		message = "\n"
				
		local chatMessage = {
			{text = "\n"}
		}
		
		for i,v in pairs(takePeripheral.list()) do
			local textColor = "white"
			if i%2 == 1 then
				textColor = "gray"
			end
			chatMessage[#chatMessage+1] = {text = v.count.." "..v.name.."\n", color = textColor}
		end
		chatMessage = textutils.serializeJSON(chatMessage)
		chatBox.sendFormattedMessageToPlayer(chatMessage, owner, chatBoxName)
	end

}

while true do

	local event, user, message, uuid, isHidden = os.pullEvent("chat")
	if isHidden and user == "EnchantedAlchemy" then
		
		local commands = {}
		
		for s in string.gmatch(message, "[%w:_]+") do
			commands[#commands+1] = s
		end
		
		local mainCommand = commands[1]
		table.remove(commands,1)
		
		if functions[mainCommand] ~= nil then
			functions[mainCommand](commands)
		end
		
	end

end
